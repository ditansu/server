#!groovy

WORK_NODE = ''

stage("Select a target node lable") {
    node('master') {
        echo "Start prepare..."

        if (BRANCH_NAME == 'devops_develop') {
            WORK_NODE = 'chstage-node'
        } else if (BRANCH_NAME == 'devops_prod') {
            WORK_NODE = 'chprod-node'
        }

        echo "end prepare the Node is ${WORK_NODE}..."
        sh 'printenv'
    }
}

node(WORK_NODE){
 ws("/home/jenkins/ch-stage/workspace/ch-server") {
    
  stage("0 of 3 Set environment"){
    //Local paths
    WORK_DIR = "${env.WORKSPACE}"
    SCRIPTS_DIR = "${WORK_DIR}/Devops"

    //MySQL config
    MYSQL_CONFIG = "/home/jenkins/ch-stage/scripts/mysql.json"
    SERVER_CONFIG_DIR = "${WORK_DIR}/Config/secrets/"
    
    //Build config
    VAPOR = "/usr/local/bin/vapor"
    BUILD_PARAM = "--verbose --release"

    //Deploy config
    env.CH_BUILD = "${env.WORKSPACE}"  // export to scripts
    env.CH_WEBROOT = "/var/www/stage" // export to scripts
    DEPLOY_SCRIPT  = "/usr/bin/sudo -E ${SCRIPTS_DIR}/deploy-build.sh"
    ROLLBACK_SCRIPT = "/usr/bin/sudo -E ${SCRIPTS_DIR}/rollback.sh"

    //For rollback config
    env.DEPLOY_STATUS = "SUCCESS"
    echo "========================"
    sh 'printenv'
    echo "========================"
  }
  stage("1 of 3 Checkout") {
      try{
        def COMMIT_MESSAGE = commitMessage()
        slackSend(
          color: 'good',
          message: "Start pipeline for ${env.BRANCH_NAME} on node ${env.NODE_NAME} commit message: '${COMMIT_MESSAGE}' Job description ${env.JOB_NAME} ${env.BUILD_NUMBER} ${env.BUILD_URL}"
        )
        echo "Start checkout on node: ${WORK_NODE}"
        checkout scm
        echo "Copy ${MYSQL_CONFIG} to ${SERVER_CONFIG_DIR}"
        sh "cp ${MYSQL_CONFIG} ${SERVER_CONFIG_DIR}"
        slackSend(
          color: 'good',
          message: "1 of 3 Chekout SUCCESS :smiley:"
        )
      }catch(err) {
        println(err.getMessage());
        throw err
      }
  }
  stage("2 of 3 Build"){
      try{
         echo "Start build: '${VAPOR} build ${BUILD_PARAM}"
         ansiColor('xterm') {
           sh "$VAPOR build $BUILD_PARAM"
         }
        slackSend(
          color: 'good',
          message: "2 of 3 Build SUCCESS :smiley:"
        )
      }catch(err) {
        slackSend(
          color: 'danger',
          message: "2 of 3 Build FAILED :scream:"
        )
        println(err.getMessage());
        throw err
      }
  }

  stage("3 of 3 Deploy"){
    try{
      echo "Start deploy by script ${DEPLOY_SCRIPT}"
      sh "$DEPLOY_SCRIPT"
      currentBuild.result = 'SUCCESS'
    }catch(err) {
      slackSend(
        color: 'danger',
        message: "3 of 3 Deploy FAILED :scream:"
      )
      println(err.getMessage());
      throw err
    }
  }

  if(env.DEPLOY_STATUS == 'FAILURE') {
    stage("ROLLBACK"){
      try{
        echo "Start rollback by ${ROLLBACK_SCRIPT}"
        sh "$ROLLBACK_SCRIPT"
        currentBuild.result = 'FAILURE'
        slackSend(
          color: 'danger',
          message: "Deploy failed but Rollback is SUCCESS :grimacing:"
        )

      } catch(err) {
        slackSend(
          color: 'danger',
          message: "Deploy FAILED and Rollback is FAILED :scream:"
        )
        println(err.getMessage());
        throw err
      }
    }
  } else {
    slackSend(
      color: 'good',
      message: "3 of 3 Deploy SUCCESS :smiley: :rocket:"
    )
  }
  
 }// workspace
}//node


def commitMessage() {
  sh 'git log --format=%B -n 1 HEAD > commitMessage'
  def commitMessage = readFile('commitMessage')
  sh 'rm commitMessage'
  commitMessage
}

